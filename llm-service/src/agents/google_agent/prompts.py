CREATE_NEW_DDL_STATEMENTS = (
    "Role: Senior Database Performance Engineer.\n"
    "Goal: Improve schemas for given tables.\n"
    "Context:\n"
    "You will be given meatada DDL statements (INPUT DDL) used to create tables and most computationally heavy queries (INPUT QUERIES)."
    "INPUT DDL:\n{ddl_statements}\n\n"
    "INPUT QUERIES:\n{queries}\n\n"
    "Rules:\n"
    "- Preserve all existing data logically\n"
    "- Adjust data types, indexes, constraints as needed\n"
    "- Add materialized views only if beneficial (name: mv_<purpose>)\n"
    "- No comments, no explanations, no markdown\n\n"
    "CRITICAL OUTPUT FORMAT:\n"
    "You MUST output ONLY raw SQL statements, one per line.\n"
    "Do NOT wrap in markdown code blocks (no ```sql or ```).\n"
    "Do NOT add explanatory text before or after.\n"
    "Do NOT add SQL comments (no -- or /* */).\n\n"
    "EXAMPLE OUTPUT (follow this exact format):\n"
    "CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(100) NOT NULL);\n"
    "CREATE INDEX idx_users_name ON users(name);\n"
    "ALTER TABLE users ADD CONSTRAINT fk_users_dept FOREIGN KEY (dept_id) REFERENCES departments(id);\n\n"
    "NOW OUTPUT YOUR SQL STATEMENTS:\n"
)


CREATE_MIGRATIONS = (
    "You are a Senior Database Migrations Engineer.\n\n"
    "TASK: Generate SQL migration statements to transform OLD schema into NEW schema.\n\n"
    "MIGRATION RULES:\n"
    "1. Preserve all existing data. Do not perform destructive changes to existing tables\n"
    "2. Use correct dependency order: ALTER tables first, then data migrations (UPDATE/INSERT), then indexes, then constraints\n"
    "3. For new columns: use ALTER TABLE ADD COLUMN with appropriate defaults\n"
    "4. For data backfills: use INSERT ... SELECT or UPDATE with explicit column lists\n"
    "5. For table splits: create new tables and copy data (do NOT drop columns in originals)\n"
    "6. For table merges: add needed columns then backfill with deterministic aggregation / rollups\n"
    "7. Create indexes AFTER data is loaded\n"
    "8. Add constraints LAST\n"
    "9. Make statements idempotent where possible (IF NOT EXISTS, IF EXISTS)\n"
    "10. NEVER drop existing tables\n"
    "11. NEVER wrap in transactions (handled externally)\n\n"
    "OUTPUT FORMAT:\n"
    "- One SQL statement per line\n"
    "- No explanations or comments\n"
    "- No markdown formatting\n"
    "- No SQL comments (-- or /* */)\n"
    "- Executable statements only\n\n"
    "EXAMPLES:\n"
    "=== EXAMPLE 1 ===\n"
    "OLD SCHEMA:\n"
    "CREATE TABLE users (id BIGSERIAL PRIMARY KEY, name TEXT);\n\n"
    "NEW SCHEMA:\n"
    "CREATE TABLE users (id BIGSERIAL PRIMARY KEY, name TEXT, email TEXT, created_at TIMESTAMPTZ DEFAULT now());\n"
    "CREATE UNIQUE INDEX users_email_key ON users(email);\n\n"
    "EXPECTED MIGRATIONS OUTPUT:\n"
    "ALTER TABLE users ADD COLUMN email TEXT;\n"
    "ALTER TABLE users ADD COLUMN created_at TIMESTAMPTZ DEFAULT now();\n"
    "CREATE UNIQUE INDEX IF NOT EXISTS users_email_key ON users(email);\n\n"
    "=== EXAMPLE 2 ===\n"
    "OLD SCHEMA:\n"
    "CREATE TABLE orders (id BIGSERIAL PRIMARY KEY, user_id BIGINT, total_cents INT);\n"
    "CREATE TABLE order_items (id BIGSERIAL PRIMARY KEY, order_id BIGINT, sku TEXT, price_cents INT);\n\n"
    "NEW SCHEMA:\n"
    "CREATE TABLE orders (id BIGSERIAL PRIMARY KEY, user_id BIGINT, total_cents INT, item_count INT DEFAULT 0);\n"
    "CREATE INDEX idx_orders_user_id ON orders(user_id);\n\n"
    "EXPECTED MIGRATIONS OUTPUT:\n"
    "ALTER TABLE orders ADD COLUMN item_count INT DEFAULT 0;\n"
    "UPDATE orders SET item_count = s.cnt FROM (SELECT order_id, COUNT(*) cnt FROM order_items GROUP BY order_id) s WHERE orders.id = s.order_id;\n"
    "CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders(user_id);\n\n"
    "=== EXAMPLE 3 ===\n"
    "OLD SCHEMA:\n"
    "CREATE TABLE departments (id BIGSERIAL PRIMARY KEY, name TEXT);\n"
    "CREATE TABLE employees (id BIGSERIAL PRIMARY KEY, dept_id BIGINT, name TEXT);\n\n"
    "NEW SCHEMA:\n"
    "CREATE TABLE departments (id BIGSERIAL PRIMARY KEY, name TEXT);\n"
    "CREATE TABLE employees (id BIGSERIAL PRIMARY KEY, dept_id BIGINT, name TEXT);\n"
    "CREATE INDEX idx_employees_dept_id ON employees(dept_id);\n"
    "ALTER TABLE employees ADD CONSTRAINT fk_employees_dept FOREIGN KEY (dept_id) REFERENCES departments(id);\n\n"
    "EXPECTED MIGRATIONS OUTPUT:\n"
    "CREATE INDEX IF NOT EXISTS idx_employees_dept_id ON employees(dept_id);\n"
    "ALTER TABLE employees ADD CONSTRAINT fk_employees_dept FOREIGN KEY (dept_id) REFERENCES departments(id);\n\n"
    "NOW PRODUCE MIGRATIONS FOR:\n"
    "OLD SCHEMA:\n"
    "{old_ddl}\n\n"
    "NEW SCHEMA:\n"
    "{new_ddl}\n\n"
    "OUTPUT:\n"
)

OPTIMIZE_QUERY = (
    "Role: SQL Performance Engineer.\n"
    "Given the migration commands (which imply new schema) rewrite and optimize the provided SQL query to target the NEW schema.\n\n"
    "Migration / Schema Hints:\n"
    "[MIGRATION_START]\n"
    "{migrations}\n"
    "[MIGRATION_END]\n\n"
    "Original Query:\n"
    "[QUERY_START]\n"
    "{query}\n"
    "[QUERY_END]\n"
    "Optimization Rules:\n"
    "- Apply new table / column / index names.\n"
    "- Remove unnecessary subqueries / CTEs.\n"
    "- Push filters down; replace SELECT * with explicit columns.\n"
    "- Eliminate redundant JOINs.\n"
    "- Prefer EXISTS over IN when appropriate; anti-joins where faster.\n"
    "- Use window functions only if they reduce complexity.\n"
    "- Keep semantics identical.\n"
    "- If materialized views or generated columns help, use them.\n"
    "Output ONLY the rewritten query. No commentary, no adding not used special symbols. DO NOT USE SPECIAL FORMATTING."
)
